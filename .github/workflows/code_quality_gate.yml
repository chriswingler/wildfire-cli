name: ðŸš¦ Code Quality Gate

on:
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - 'src/**'
      - 'tests/**'
      - '*.py'

permissions:
  contents: read
  pull-requests: write
  checks: write

jobs:
  coding_standards_check:
    name: Coding Standards Compliance
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install flake8 black mypy bandit safety xmltodict # Added xmltodict
          # Ensure pytest and pytest-cov are installed for coverage check
          pip install pytest pytest-cov
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

      - name: Run tests and collect coverage
        id: run_tests
        run: |
          pytest --cov=src --cov-report=xml tests/
        # Continue on error so subsequent steps like coverage check can run if tests fail
        # The overall job will still fail if tests fail.
        continue-on-error: true

      - name: Check code coverage
        id: coverage_check
        if: always() # Run even if previous steps failed, to report coverage status
        run: |
          import xmltodict
          import os

          coverage_threshold = 20.0  # Percentage
          coverage_file = "coverage.xml"
          actual_coverage = 0.0
          coverage_passed = False
          summary = ""

          if not os.path.exists(coverage_file):
              summary = f"âŒ **Code Coverage:** Failed! {coverage_file} not found."
              print(f"::error::Coverage report {coverage_file} not found.")
          else:
              with open(coverage_file, 'r') as f:
                  data = xmltodict.parse(f.read())

              # Extract line rate from coverage.xml
              # The exact path might vary slightly based on pytest-cov version, but 'coverage'.'packages'.'package'.'lines'.'line-rate' is common
              try:
                  line_rate_str = data['coverage']['packages']['package'][0]['lines']['@line-rate']
                  # pytest-cov often stores this as a fraction (e.g., "0.8523")
                  actual_coverage = float(line_rate_str) * 100
              except Exception as e:
                  summary = f"âŒ **Code Coverage:** Failed! Could not parse coverage data from {coverage_file}. Error: {e}"
                  print(f"::error::Could not parse coverage data from {coverage_file}. Error: {e}")

              if actual_coverage >= coverage_threshold:
                  coverage_passed = True
                  summary = f"âœ… **Code Coverage:** {actual_coverage:.2f}% (Threshold: >{coverage_threshold}%)"
              else:
                  summary = f"âŒ **Code Coverage:** {actual_coverage:.2f}% - FAILED! (Threshold: >{coverage_threshold}%)"
                  print(f"::error::Code coverage ({actual_coverage:.2f}%) is below the threshold of {coverage_threshold}%.")

          print(f"Coverage summary: {summary}")
          # Set output for use in later steps if needed
          print(f"::set-output name=summary::{summary}")
          print(f"::set-output name=passed::{str(coverage_passed).lower()}")

          if not coverage_passed:
            # This will make the step fail if coverage is too low
            exit(1)
        env:
          PYTHONPATH: .:src # Ensure pytest can find modules

      - name: Check coding standards compliance
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { exec } = require('child_process');
            const util = require('util');
            const execAsync = util.promisify(exec);
            
            // Read our coding standards for reference
            const codingStandards = fs.readFileSync('./docs/coding_standards.md', 'utf8');
            
            // Test and Coverage Information
            const coverageSummary = "${{ steps.coverage_check.outputs.summary }}";
            const testsPassed = "${{ steps.run_tests.outcome }}" === "success";
            let testReport = `## ðŸ§ª Test Results\n\n`;
            if (testsPassed) {
              testReport += `âœ… **Tests:** All tests passed.\n`;
            } else {
              testReport += `âŒ **Tests:** Some tests failed. Please review the test logs.\n`;
            }
            testReport += `${coverageSummary}\n\n`;

            let qualityReport = "## ðŸš¦ Code Quality Gate Report\n\n";
            qualityReport = testReport + qualityReport; // Add test and coverage info at the beginning
            qualityReport += `**Standards Reference**: [docs/coding_standards.md](https://github.com/chriswingler/wildfire-cli/blob/main/docs/coding_standards.md)\n\n`;
            
            let allPassed = true;
            // Ensure overall failure if tests failed or coverage check failed at the start
            if (!testsPassed || "${{ steps.coverage_check.outputs.passed }}" !== "true") {
              allPassed = false;
            }
            let issues = [];
            
            // 1. Code Formatting Check (Black)
            try {
              const { stdout, stderr } = await execAsync('black --check --diff src/ tests/ || true');
              if (stderr || stdout.includes('would reformat')) {
                allPassed = false;
                issues.push({
                  tool: "Black (Code Formatting)",
                  status: "âŒ FAIL",
                  details: "Code formatting issues detected",
                  fix: "Run `black src/ tests/` to auto-format"
                });
              } else {
                issues.push({
                  tool: "Black (Code Formatting)", 
                  status: "âœ… PASS",
                  details: "Code formatting is consistent"
                });
              }
            } catch (error) {
              console.log('Black check error:', error.message);
            }
            
            // 2. Style Guide Compliance (Flake8)
            try {
              const { stdout, stderr } = await execAsync('flake8 src/ tests/ --max-line-length=120 --extend-ignore=E203,W503 || true');
              if (stdout.trim()) {
                allPassed = false;
                const errorCount = stdout.split('\n').filter(line => line.trim()).length;
                issues.push({
                  tool: "Flake8 (Style Guide)",
                  status: "âŒ FAIL", 
                  details: `${errorCount} style violations detected`,
                  fix: "Review flake8 output and fix style issues"
                });
              } else {
                issues.push({
                  tool: "Flake8 (Style Guide)",
                  status: "âœ… PASS",
                  details: "No style violations found"
                });
              }
            } catch (error) {
              console.log('Flake8 check error:', error.message);
            }
            
            // 3. Type Checking (MyPy) 
            try {
              const { stdout, stderr } = await execAsync('mypy src/ --ignore-missing-imports || true');
              if (stdout.includes('error:')) {
                allPassed = false;
                const errorCount = (stdout.match(/error:/g) || []).length;
                issues.push({
                  tool: "MyPy (Type Checking)",
                  status: "âš ï¸ WARN",
                  details: `${errorCount} type issues detected`,
                  fix: "Add type hints and fix type errors"
                });
              } else {
                issues.push({
                  tool: "MyPy (Type Checking)",
                  status: "âœ… PASS", 
                  details: "No type errors found"
                });
              }
              // Add MyPy informational comment
              issues.push({
                tool: "MyPy (Type Checking)",
                status: "â„¹ï¸ INFO",
                details: "Consider making MyPy checks stricter in the future (e.g., by removing --ignore-missing-imports or being more specific, or by adding `--disallow-untyped-defs`).",
                fix: "Review MyPy documentation for stricter options like `--disallow-untyped-defs` or project-wide configuration."
              });
            } catch (error) {
              console.log('MyPy check error:', error.message);
            }
            
            // 4. Security Check (Bandit)
            try {
              const { stdout, stderr } = await execAsync('bandit -r src/ -f json || true');
              if (stdout.includes('"results"')) {
                const results = JSON.parse(stdout);
                if (results.results && results.results.length > 0) {
                  const highSeverity = results.results.filter(r => r.issue_severity === 'HIGH').length;
                  if (highSeverity > 0) {
                    allPassed = false;
                    issues.push({
                      tool: "Bandit (Security)",
                      status: "âŒ FAIL",
                      details: `${highSeverity} high-severity security issues found`,
                      fix: "Review and fix security vulnerabilities"
                    });
                  } else {
                    issues.push({
                      tool: "Bandit (Security)",
                      status: "âš ï¸ WARN", 
                      details: `${results.results.length} minor security issues found`,
                      fix: "Review security recommendations"
                    });
                  }
                } else {
                  issues.push({
                    tool: "Bandit (Security)",
                    status: "âœ… PASS",
                    details: "No security issues detected"
                  });
                }
              }
            } catch (error) {
              console.log('Bandit check error:', error.message);
            }
            
            // Build quality report
            qualityReport += `### ðŸ” Quality Checks\n\n`;
            qualityReport += `| Tool | Status | Details |\n`;
            qualityReport += `|------|--------|----------|\n`;
            
            for (const issue of issues) {
              qualityReport += `| ${issue.tool} | ${issue.status} | ${issue.details} |\n`;
            }
            
            qualityReport += `\n### ðŸ“‹ Coding Standards Compliance\n\n`;
            
            if (allPassed) {
              qualityReport += `ðŸŽ‰ **All quality checks passed!** This PR meets our coding standards.\n\n`;
            } else {
              qualityReport += `âš ï¸ **Some quality checks failed.** Please address the issues below:\n\n`;
              
              const failedChecks = issues.filter(i => i.status.includes('âŒ'));
              for (const check of failedChecks) {
                if (check.fix) {
                  qualityReport += `- **${check.tool}**: ${check.fix}\n`;
                }
              }
              qualityReport += `\n`;
            }
            
            qualityReport += `### ðŸ“– Coding Standards Reference\n\n`;
            qualityReport += `Our coding standards emphasize:\n`;
            qualityReport += `- **KISS, DRY, YAGNI** principles\n`;
            qualityReport += `- **Functions**: Max 60 lines, single responsibility\n`;
            qualityReport += `- **Files**: Max 1000 lines, logical organization\n`;
            qualityReport += `- **Naming**: Descriptive and unambiguous\n`;
            qualityReport += `- **Error Handling**: Proper exceptions with context\n`;
            qualityReport += `- **Testing**: Comprehensive test coverage\n\n`;
            
            qualityReport += `### ðŸ”§ Quick Fixes\n\n`;
            qualityReport += `\`\`\`bash\n`;
            qualityReport += `# Auto-format code\n`;
            qualityReport += `black src/ tests/\n\n`;
            qualityReport += `# Check style\n`;
            qualityReport += `flake8 src/ tests/ --max-line-length=120\n\n`;
            qualityReport += `# Type checking\n`;
            qualityReport += `mypy src/ --ignore-missing-imports\n\n`;
            qualityReport += `# Security scan\n`;
            qualityReport += `bandit -r src/\n`;
            qualityReport += `\`\`\`\n\n`;
            
            qualityReport += `---\n`;
            qualityReport += `*Automated quality gate based on [docs/coding_standards.md](https://github.com/chriswingler/wildfire-cli/blob/main/docs/coding_standards.md)*`;
            
            // Create check run for quality gate
            // Final check on allPassed before creating the check run
            if (!testsPassed || "${{ steps.coverage_check.outputs.passed }}" !== "true") {
              allPassed = false;
            }
            await github.rest.checks.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'Coding Standards Compliance',
              head_sha: context.payload.pull_request.head.sha,
              status: 'completed',
              conclusion: allPassed ? 'success' : 'failure',
              output: {
                title: allPassed ? 'âœ… All quality checks passed' : 'âŒ Quality issues detected',
                summary: allPassed ? 
                  'This PR meets all coding standards requirements.' : 
                  'This PR has quality issues that need to be addressed.',
                text: qualityReport
              }
            });
            
            // Post comment with quality report
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: qualityReport
            });
            
            // Set action status
            if (!allPassed) {
              core.setFailed('Code quality checks failed. Please review the quality report.');
            }

  educational_content_review:
    name: Educational Content Review
    runs-on: ubuntu-latest
    if: contains(github.event.pull_request.changed_files, 'src/')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Review educational value
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Check if this PR enhances educational value
            let educationalReview = "## ðŸŽ“ Educational Content Review\n\n";
            
            const prTitle = context.payload.pull_request.title;
            const prBody = context.payload.pull_request.body || '';
            
            // Educational criteria
            let educationalScore = 0;
            let feedback = [];
            
            // Check PR description for educational context
            const educationalKeywords = [
              'ics', 'incident command', 'wildfire', 'firefighting', 
              'tactical', 'operational', 'educational', 'learning',
              'authentic', 'realistic', 'training'
            ];
            
            for (const keyword of educationalKeywords) {
              if (prTitle.toLowerCase().includes(keyword) || prBody.toLowerCase().includes(keyword)) {
                educationalScore++;
              }
            }
            
            if (educationalScore >= 2) {
              feedback.push("âœ… PR demonstrates clear educational value");
            } else {
              feedback.push("ðŸ’¡ Consider explaining the educational benefit of this change");
            }
            
            // Check for authentic terminology usage
            if (prBody.includes('ICS') || prBody.includes('incident command')) {
              feedback.push("âœ… Uses authentic wildfire management terminology");
            }
            
            // Check for learning objective alignment
            if (prBody.includes('learn') || prBody.includes('teach') || prBody.includes('understand')) {
              feedback.push("âœ… Explicitly addresses learning objectives");
            }
            
            educationalReview += `### ðŸ“š Educational Criteria Check\n\n`;
            for (const item of feedback) {
              educationalReview += `- ${item}\n`;
            }
            
            educationalReview += `\n### ðŸŽ¯ Educational Standards\n\n`;
            educationalReview += `This project teaches authentic wildfire incident command:\n`;
            educationalReview += `- **Real ICS protocols** and terminology\n`;
            educationalReview += `- **Tactical decision-making** with consequences\n`;
            educationalReview += `- **Resource management** principles\n`;
            educationalReview += `- **Professional practices** from real emergency management\n\n`;
            
            educationalReview += `### ðŸ’¡ Educational Enhancement Suggestions\n\n`;
            educationalReview += `- Use authentic wildfire/ICS terminology in code and comments\n`;
            educationalReview += `- Include educational context in complex algorithms\n`;
            educationalReview += `- Explain real-world basis for game mechanics\n`;
            educationalReview += `- Consider learning outcomes when designing features\n\n`;
            
            educationalReview += `---\n`;
            educationalReview += `*Educational review ensures authentic learning value*`;
            
            // Only post if there are meaningful educational aspects to review
            if (educationalScore > 0 || feedback.length > 1) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: educationalReview
              });
            }
            
            console.log(`Educational review completed (score: ${educationalScore})`);